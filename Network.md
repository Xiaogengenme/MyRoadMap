网络分层结构：

![image-20210804151814729](/Users/xiaogengen/Desktop/秋招/MyRoadMap/Network.assets/image-20210804151814729.png)

## HTTP协议

### HTTP协议的操作流程

分层画图解释：

*** 这里应该有个图 ***

### HTTP请求

HTTP请求包含三个部分：请求行、请求首部与请求内容

* 请求行：

  方法：包括GET、POST、PUT、DELETE等，

  这里要提到GET和POST的区别：其中GET主要是从主机中获取，获取的可能是个JSON也可能是其他数据格式，比如获取主机的数量。而POST是发送方主动要告诉主机一些信息，具体信息内容存放在请求实体中，比如通知主机创建一个新的服务器。

  具体的POST、GET的区别写在后面。

  PUT和POST的区别：POST往往用于创建一个资源而PUT往往用于修改一个资源。

  

![截屏2021-08-04 下午1.58.04](/Users/xiaogengen/Desktop/秋招/MyRoadMap/Network.assets/截屏2021-08-04 下午1.58.04.png)

* 请求头部字段

![截屏2021-08-04 下午1.59.03](/Users/xiaogengen/Desktop/秋招/MyRoadMap/Network.assets/截屏2021-08-04 下午1.59.03.png)

#### GET和POST方法的区别

#### 请求头部字段

* Accept-Charset：客户端可以接收的字符集
* Content-Type：正文的格式（比如JSON）
* Cache-control：用于管理缓存，如果客户端发到服务器的请求中，包含max-age，代表超过这个年龄的数据我客户端不要，那么服务器就需要在Tomcat应用集群中获取最新的数据发给客户端
* If-Modified-Since也是关于缓存的，就是说客户端会询问服务器端在某个时间点之后，资源是否有更新，如果更新了那么客户端需要下载最新的，如果没更新服务端会给客户端返回“304 Not Modified”响应，客户端不用重新获取。

### HTTP缓存

网页信息中，有一部分是需要实时更新的动态资源如商品库存，而有一些是不怎么更新的静态资源如商品图片，商品介绍

我们每次更新数据的时候需要更新整个页面，如果全都从服务器重新获取一遍的话，服务器压力很大。

所以在高并发场景下，我们需要使用一个接入层，将静态资源请求拦截在服务器外面

<img src="/Users/xiaogengen/Library/Application Support/typora-user-images/截屏2021-08-04 下午2.11.14.png" alt="截屏2021-08-04 下午2.11.14" style="zoom:50%;" />

和这个场景关系较大的就是nginx服务器，将静态资源的请求转发到Varnish服务器，将动态资源的请求发送到Redis服务器。对于Varnish服务器，只有静态资源过期时才会访问到Tomcat服务器。

#### ⭐️ETag响应头

是一个响应头，由服务器端发送给客户端。

浏览器第一次请求一个资源的时候，服务端给予返回，并且返回了ETag: "50b1c1d4f775c61:df3" 这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将If-None-Match: W/"50b1c1d4f775c61:df3" 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。

**客户端在向服务端请求资源的时候，通过If-None-Match请求头带上了之前服务端返回的Etag的值。服务端收到第二次请求的时候，发现携带了If-None-Match字段，就重新计算服务器对应资源的Etag，如果二者匹配了，就认为资源没有发生变化，直接给客户端相应304，让客户端读取缓存中的数据。**



### HTTP请求的发送

#### 传输层

在应用层构建好了HTTP请求后，会交由TCP层也就是传输层进行发送，TCP是面向连接，基于流的协议，TCP将二进制流封装成报文段发送出去

这里传输层包含了很多TCP的机制，包括数据顺序可靠，超时重传等

TCP层将请求添加IP头，IP头中包括源地址与目标地址，交由IP层进行发送

#### 网络层

IP层需要查看目标地址是否与自己处于同一个局域网。

如果处于同一个局域网，就通过ARP协议来请求目标地址对应的MAC地址，然后将源MAC和目标MAC放进MAC头，发送出去。

如果不处于同一个局域网，需要ARP协议请求到网关所在的MAC地址，将数据发送到网关。

网关收到发送给自己的数据报之后，取出其中的目标IP地址，并通过路由协议找到下一跳路由器目标的MAC地址，将数据包发送给下一跳路由器。

这样一跳一跳地发送到最后一个路由器之后，最后一个路由器发现目标IP地址与自己处于同一个局域网，再使用ARP协议找到目标IP地址的MAC地址，将数据包发送给他。

#### 收信人网络层

收信人收到数据包后验证目标IP地址是自己，拆掉IP头包装，发送给TCP层

#### 收信人TCP层

拆开IP头（快递包装）后，验证TCP头中的序列号，是不是自己需要的序列号，如果符合就将数据放入缓存，返回ACK，如果不符合则丢弃。

#### 收信人应用层

TCP头中含有端口号，收信人的HTTP服务器会监听某个端口号，当对应端口号有数据到达时，读出数据发送给上层。

### HTTP返回报文

<img src="/Users/xiaogengen/Desktop/秋招/MyRoadMap/Network.assets/截屏2021-08-04 下午3.12.08.png" alt="截屏2021-08-04 下午3.12.08" style="zoom:50%;" />



### HTTP状态码

* 1XX：提示信息，协议处理的中间状态

* 2XX：服务器成功处理了客户端的请求

  * [200 OK]：最常见的成功状态码，如果是非HEAD请求服务器返回的响应头会有body数据
  * [204 No Content]：成功，响应头没有body数据
  * [206 Partial Content]：HTTP分块下载或或断电续传，body内容不是全部只是一部分

* 3XX：重定向

  * [301 Moved Permanently]：永久重定向

  * [302 Temporary Redirect]：临时重定向，301、302都会使用location字段指向重定向URL

    **301永久重定向和302临时重定向的区别：**

    永久重定向指当前访问URI的网址的内容永久搬到另一个URI，浏览器下次访问的时候也是默认直接访问迁移的URI。临时重定向顾名思义。

  * [304 Not Modified]：缓存重定向

* 4XX：错误

  * [400 Bad Request]：客户端向服务端发送的报文存在错误
  * [403 Forbidden]：服务器端不允许客户端的访问
  * [404 Not Found]：服务器资源找不到

* 5XX：服务器端错误码

  * 500：服务器错误（笼统）
  * 501：服务器作为网管访问后端服务器时故障
  * 502：当前功能还没支持，即将开业
  * 503：服务器正忙

### HTTP1.1

1. **缓存处理**

   相较于HTTP1.0请求头里面使用if-modified-since和expires来做缓存判断的标准，HTTP1.1中新增了更多的缓存控制策略

2. **带宽优化以及网络连接的使用**

   HTTP1.0中有一次浪费带宽的行为，比如可能只需要某个对象的一个部分，但是会把整个对象传回来

3. **新增错误状态码**

4. **Host头的处理**

   在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

5. **长连接**

   HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

### HTTP2.0

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能

### cookie与session的区别

cookie主要用于存放用户的信息，以便用户下次登录的时候可以更快速地添加一下基本信息。

一般网页实现第二次直接登录的方法就是为用户信息生成一个token存放在用户的cookie中，下次就可以直接登录（为了安全每次重新登录都会更新token）

同时cookie还满足用户在访问一个网站的其他页面是也无需重新登录。

session主要用于保存用户状态，比如用户的购物车信息等。

session一般存放在服务器中，cookie一般存放在内存中（浏览器中）





## HTTPS

### 🌟HTTP和HTTPS区别

HTTP和HTTPS最大的区别就是安全性的区别，HTTP是使用明文传输，而HTTPS是使用密文传输的。

要生成密文就涉及到加密算法以及密钥的生成，所以HTTPS较HTTP的TCP协议基础上增加了SSL协议，所以建立连接的握手机制也比HTTP更复杂一些。

### HTTPS目的是解决HTTP哪些问题？

1. 窃听风险
2. 篡改风险
3. 冒充风险（中间人攻击）

### HTTPS如何解决上述问题

1. 采用混合加密的方式来实现信息的机密性，防止信息被窃听的风险
2. 摘要算法来实现校验数据的完整性，解决被篡改的风险
3. 身份验证机制防止冒充的风险

#### 混合加密

> 非对称加密：公钥加密私钥解密。客户端向服务器端申请服务器端的公钥，使用公钥对数据进行加密传输，服务器端收到密文后使用自己的私钥进行解密。

* 在通信建立之前采用非对称加密的方式
* 在通信建立之后采用对称加密来传输数据

#### 摘要算法

摘要算法通过给数据生成独一无二的指纹来校验数据的完整性，解决数据被篡改的风险。

发送方通过摘要算法算出要传输数据明文的指纹，并将指纹+明文一同加密成密文传输给接收方，接收方收到密文解密后通过相同的摘要算法计算明文的指纹，并与传输过来的指纹进行对比

#### 数字证书

**解决的问题**：非对称加密建立连接的过程中，客户端需要向服务器端申请它的公钥，用于后续加密消息传递密文，但这次申请没有安全保证，无法确认公钥的信任度。

借助第三方权威机构CA（数字证书认证机构），将服务器公钥放在数字证书中。

### 🌟HTTPS的建立连接过程

HTTPS的加密传输涉及到加密算法，加密算法有两种，对称加密和非对称加密。而HTTPS使用的是混合加密的方式，在简历连接时采用非对称加密，一旦连接建立，随后的通信使用对称加密进行传输。

HTTPS建立连接的过程主要有以下三个步骤：客户端验证服务器端的CA证书-双方协商生成对话密钥-双方使用密钥进行加密通信。

具体来说有四步：

1. clientHello，客户端向服务器端发送加密传输请求，传输的内容包括客户端的SSL协议版本，客户端支持的加密算法和一个随机数
2. serverHello：服务器端回应客户端，传输内容主要包括服务器端的CA证书，服务器端选择的加密算法，和第二个随机数
3. 客户端接下来通过操作系统或浏览器来验证服务器端的CA证书身份，如果验证成功则向服务器发送确认信息，包括第三个随机数，加密算法改变通知（要从非对称加密改为对称加密），和客户端握手结束通知（会将之前涉及的所有数据打包通过摘要算法生成一个最终结果）
4. 服务器端收到第三个随机数后通过三个随机数计算出本次通话的加密密钥，并向客户端传回：加密算法更改信息，和握手结束通知（数据摘要）

### 常见的网络攻击

1. SQL注入

2. 零日攻击

   **保护自身不受零日攻击影响最简便的方法，就是在新版本发布后及时更新。**

3. DDoS攻击

   DDoS攻击就是用大量请求压垮目标服务器，攻击者再利用DDoS攻击吸引安全系统火力，从暗中利用漏洞入侵系统。

   **避免DDoS攻击，首先，需通过内容分发网络（CDN）、负载均衡器和可扩展资源缓解高峰流量。其次，需部署Web应用防火墙（WAF），防止DDoS攻击隐蔽注入攻击或跨站脚本等其他网络攻击方法。**

4. 中间人攻击

5. 暴力破解密码

6. 网络钓鱼

### Diffie-Hellman密钥交换算法





## DNS

## CDN

## NAT

### 网关

跨网关访问的时候牵扯到IP地址与MAC地址的变化

网关一般是一个路由器，是一个三层转发设备，三层转发设备是指在收到收据包的时候要取下MAC头和IP头两层头，判断其中的内容然后将数据转发出去。

### 静态路由

静态路由根据路由器自己维护的静态的路由表来进行数据包的转发。

### 路由过程中MAC头与IP头的变化

#### 欧洲十国游类型

<img src="/Users/xiaogengen/Desktop/秋招/MyRoadMap/Network.assets/截屏2021-08-04 下午2.40.31.png" alt="截屏2021-08-04 下午2.40.31" style="zoom:50%;" />

整个流程下来**IP地址是不变的**，服务器A通过IP地址层层转发找到服务器B，期间每次转发都会通过ARP协议来获取下一跳的MAC地址，并更新源MAC地址和目标MAC地址。

#### 玄奘西行类型——公网与NAT

![截屏2021-08-04 下午2.40.58](/Users/xiaogengen/Desktop/秋招/MyRoadMap/Network.assets/截屏2021-08-04 下午2.40.58.png)

服务器需要访问公网时，需要经过NAT网关将**内网IP地址转换为公网的IP地址**，服务器A想访问服务器B，需要知道服务器B在公网上的IP地址，到达服务器B的网关时再将目标IP地址转化为内网的地址。整个过程源IP地址并不需要改变成公网IP。

**注意以上都是以静态路由为示例**

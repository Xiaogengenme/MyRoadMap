网络分层结构：

![image-20210804151814729](https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/202108301737493.png)

## TCP协议。。。

#### TCP四次握手的流程和状态变化

#### TCP关闭一个连接具体是怎么关闭的

#### 除了客户端可以关闭连接服务器端也可以关闭连接吗？

#### ⭐️TCP为什么是可靠的？

#### ⭐️TCP的拥塞控制

#### UDP和TCP可以用于广播吗？如何广播？

#### TCP和HTTP的关系

### TCP与UDP的区别

1. TCP是面向连接的协议，UDP是面向非连接的协议
2. TCP传输的数据是有状态，可控制的，保证了传输的可靠性
3. UDP传输是基于数据报的，TCP为了传输的可靠性，将IP包变成了字节流

### TCP的三次握手和四次挥手过程？

#### 三次握手的过程

#### 两次握手为什么不行？

> 三次握手是为了保证两端的接收能力和发送能力

考虑情况一个发起方发送第一个SYN没有送达，第二个SYN成功通过两次握手建立了连接，这次连接没有问题

但是断开连接之后如果接收端接收到了第一个SYN，接收端默认发出了ACK就默认建立了链接，这时候发送方这边是不具有接收能力的

#### 🌟四次挥手的过程：

> 流程问题，注意四次挥手时所传递的信息，FIN-ACK-FIN+ACK-ACK

以客户端主动释放断开连接消息为例：

1. 客户端首先向服务器端发送一个断开连接的申请FIN
2. 服务器端向客户端传回确认ACK

3. 服务器端把要发的数据发完之后，向客户端也发送一个断开连接请求
4. 客户端再传一个确认信息给服务器端ACK，随后等待两个MSL（最大报文生成时间）之后断开连接

#### 🌟四次挥手为什么要等待2MSL？

##### 为了确认接收端收到了断开连接的确认消息

等待两个报文最大生成时间的原因是确认对方成功收到ACK消息，ACK传达到服务器的最长时间是1MSL，如果超过这个时间服务器端给主动断开端重传FIN，重传的FIN生存时间也是1MSL，等待2MSL也是为了如果ACK丢失确认服务器端可以收到重传的FIN

##### 为了清空这次连接存在在网络空间中的所有数据包

如果client直接closed，然后又向server发起了一个新连接，我们不能保证这个新连接和刚关闭的连接的端口号是不同的。假设新连接和已经关闭的老端口号是一样的，如果前一次滞留的某些数据仍然在网络中，这些延迟数据会在新连接建立后到达Server，所以socket就认为那个延迟的数据是属于新连接的，数据包就会发生混淆。所以client要在TIME_WAIT状态等待2倍的MSL，这样保证本次连接的所有数据都从网络中消失。

### TCP为什么是可靠的传输协议？

### TCP的流量控制/滑动窗口

TCP流量控制是为了避免发送端发送数据的速度超过接受端的能力从而造成数据丢失的情况。

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了数据包无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

#### 流量控制是否会引发死锁？如何解决？

如果接收方给发送方发送了一个窗口大小为0的应答，发送方将不会继续传数据。但之后接收方向发送方发送窗口不为0的应答如果丢失，那么接收方等待发送方数据，发送方以为接收方窗口为0，就造成了死锁。

解决：发送方维持计时器，每次计时器到时间就主动询问接收方的窗口大小。

### TCP的拥塞控制

#### 如何判断网络是否拥塞

拥塞控制主要来避免两种现象：***包丢失和超时重传***。所以可以通过观察这两个现象是否有增多来判断网络是否拥塞。

主要通过观察网络的吞吐量

流量控制是作用在发送端和接收端防止数据丢失，而拥塞控制是作用于整个网络环境的，防止因为网络环境的限制造成数据的丢失，出错。

拥塞控制主要包括以下几种算法：

* 慢启动
* 拥塞避免
* 快恢复与快重传

#### 慢启动

慢启动算法的思路就是不要一开始就大量传输数据，要探测网络可承受的流量大小，一点点增大发送方拥塞窗口的大小。

如何增大：每个传输轮次的时间是RTT，慢启动算法每经过一个传输轮次就将拥塞窗口的大小加倍。

轮次的概念：

![img](https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/202108301738776.jpg)

同时，慢启动算法中还需要有一个变量是ssthresh，是慢启动算法和拥塞避免算法的切换点

#### 拥塞避免算法

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。

##### 如果增长太快出现拥塞

> 重新设置阈值（出现拥塞时拥塞窗口大小的一半）和拥塞窗口的大小（重置1），然后执行慢开始算法

无论是在慢开始阶段还是在拥塞避免阶段，**只要发送方判断网络出现拥塞**（其**根据就是没有按时收到确认**，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以**都当做拥塞来处理**），就把慢开始阈值ssthresh设置为出现拥塞时的**发送窗口大小的一半**（但不能小于2）。然后**把拥塞窗口cwnd重新设置为1**，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

> 快速重传算法和快恢复算法是一起使用的

#### 快重传算法

> 分为发送方和接收方

快重传要求接收方接收到一个失序的报文段时**立刻发送重复确认**，而不是等到自己发送数据时捎带确认。

要求发送方只要收到**三个重复的确认就应该立即重传对方尚未收到的报文段**，而不是等到重传计时器到期。

#### 快恢复算法

当发送端收到接收端发送的三个数据包的确认帧就说明要重传这个确认帧下一个序号的数据包。但是这个和**超时重传有一定区别，因为三个ack都可以送到发送端，所以发生快重传的时候发送端会认为当前的情况不是很严重，不会直接使用拥塞避免算法将拥塞窗口缩小太多**。而是：

将拥塞窗口cwnd大小减半，将阈值ssthresh设置为cwnd（不是减半之后）

这样就没有像拥塞避免算法那样从1开始。

### ARQ协议

自动重传协议，用于数据的错误纠正。它通过使用**确认和超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。**如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送**。

#### 停等ARQ（stop-and-wait）

#### 连续ARQ——回退N帧ARQ（Go-Back-N）

1. 接收端丢弃从第一个没有收到的数据包开始的所有数据包
2. 发送端收到NACK后，从NACK中指明的数据包开始重新发送

#### 连续ARQ——选择性重传ARQ协议（Selective Repeat）

1. 发送端连续发送数据包但对每个数据包都设有个一个计时器
2. 当在一定时间内没有收到某个数据包的ACK时，发送端只重新发送那个没有ACK的数据包







## HTTP协议

### HTTP协议的操作流程

分层画图解释：

*** 这里应该有个图 ***

### HTTP请求

HTTP请求包含三个部分：请求行、请求首部与请求内容

* 请求行：

  方法：包括GET、POST、PUT、DELETE等，

  这里要提到GET和POST的区别：其中GET主要是从主机中获取，获取的可能是个JSON也可能是其他数据格式，比如获取主机的数量。而POST是发送方主动要告诉主机一些信息，具体信息内容存放在请求实体中，比如通知主机创建一个新的服务器。

  具体的POST、GET的区别写在后面。

  PUT和POST的区别：POST往往用于创建一个资源而PUT往往用于修改一个资源。

  

![截屏2021-08-04 下午1.58.04](https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/20210816112545.png)

* 请求头部字段

![截屏2021-08-04 下午1.59.03](https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/20210816112545.png)

#### GET和POST方法的区别

#### 请求头部字段

* Accept-Charset：客户端可以接收的字符集
* Content-Type：正文的格式（比如JSON）
* Cache-control：用于管理缓存，如果客户端发到服务器的请求中，包含max-age，代表超过这个年龄的数据我客户端不要，那么服务器就需要在Tomcat应用集群中获取最新的数据发给客户端
* If-Modified-Since也是关于缓存的，就是说客户端会询问服务器端在某个时间点之后，资源是否有更新，如果更新了那么客户端需要下载最新的，如果没更新服务端会给客户端返回“304 Not Modified”响应，客户端不用重新获取。

### HTTP缓存

网页信息中，有一部分是需要实时更新的动态资源如商品库存，而有一些是不怎么更新的静态资源如商品图片，商品介绍

我们每次更新数据的时候需要更新整个页面，如果全都从服务器重新获取一遍的话，服务器压力很大。

所以在高并发场景下，我们需要使用一个接入层，将静态资源请求拦截在服务器外面

<img src="https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/20210812155735.png" alt="截屏2021-08-04 下午2.11.14" style="zoom:50%;" />

和这个场景关系较大的就是nginx服务器，将静态资源的请求转发到Varnish服务器，将动态资源的请求发送到Redis服务器。对于Varnish服务器，只有静态资源过期时才会访问到Tomcat服务器。

#### ⭐️ETag响应头

是一个响应头，由服务器端发送给客户端。

浏览器第一次请求一个资源的时候，服务端给予返回，并且返回了ETag: "50b1c1d4f775c61:df3" 这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将If-None-Match: W/"50b1c1d4f775c61:df3" 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。

**客户端在向服务端请求资源的时候，通过If-None-Match请求头带上了之前服务端返回的Etag的值。服务端收到第二次请求的时候，发现携带了If-None-Match字段，就重新计算服务器对应资源的Etag，如果二者匹配了，就认为资源没有发生变化，直接给客户端相应304，让客户端读取缓存中的数据。**



### HTTP请求的发送

#### 传输层

在应用层构建好了HTTP请求后，会交由TCP层也就是传输层进行发送，TCP是面向连接，基于流的协议，TCP将二进制流封装成报文段发送出去

这里传输层包含了很多TCP的机制，包括数据顺序可靠，超时重传等

TCP层将请求添加IP头，IP头中包括源地址与目标地址，交由IP层进行发送

#### 网络层

IP层需要查看目标地址是否与自己处于同一个局域网。

如果处于同一个局域网，就通过ARP协议来请求目标地址对应的MAC地址，然后将源MAC和目标MAC放进MAC头，发送出去。

如果不处于同一个局域网，需要ARP协议请求到网关所在的MAC地址，将数据发送到网关。

网关收到发送给自己的数据报之后，取出其中的目标IP地址，并通过路由协议找到下一跳路由器目标的MAC地址，将数据包发送给下一跳路由器。

这样一跳一跳地发送到最后一个路由器之后，最后一个路由器发现目标IP地址与自己处于同一个局域网，再使用ARP协议找到目标IP地址的MAC地址，将数据包发送给他。

#### 收信人网络层

收信人收到数据包后验证目标IP地址是自己，拆掉IP头包装，发送给TCP层

#### 收信人TCP层

拆开IP头（快递包装）后，验证TCP头中的序列号，是不是自己需要的序列号，如果符合就将数据放入缓存，返回ACK，如果不符合则丢弃。

#### 收信人应用层

TCP头中含有端口号，收信人的HTTP服务器会监听某个端口号，当对应端口号有数据到达时，读出数据发送给上层。

### HTTP返回报文

<img src="https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/20210816112557.png" alt="截屏2021-08-04 下午3.12.08" style="zoom:50%;" />



### HTTP状态码

* 1XX：提示信息，协议处理的中间状态

* 2XX：服务器成功处理了客户端的请求

  * [200 OK]：最常见的成功状态码，如果是非HEAD请求服务器返回的响应头会有body数据
  * [204 No Content]：成功，响应头没有body数据
  * [206 Partial Content]：HTTP分块下载或或断电续传，body内容不是全部只是一部分

* 3XX：重定向

  * [301 Moved Permanently]：永久重定向

  * [302 Temporary Redirect]：临时重定向，301、302都会使用location字段指向重定向URL

    **301永久重定向和302临时重定向的区别：**

    永久重定向指当前访问URI的网址的内容永久搬到另一个URI，浏览器下次访问的时候也是默认直接访问迁移的URI。临时重定向顾名思义。

  * [304 Not Modified]：缓存重定向

* 4XX：错误

  * [400 Bad Request]：客户端向服务端发送的报文存在错误
  * [403 Forbidden]：服务器端不允许客户端的访问
  * [404 Not Found]：服务器资源找不到

* 5XX：服务器端错误码

  * 500：服务器错误（笼统）
  * 501：服务器作为网管访问后端服务器时故障
  * 502：当前功能还没支持，即将开业
  * 503：服务器正忙

### HTTP1.1

1. **缓存处理**

   相较于HTTP1.0请求头里面使用if-modified-since和expires来做缓存判断的标准，HTTP1.1中新增了更多的缓存控制策略

2. **带宽优化以及网络连接的使用**

   HTTP1.0中有一次浪费带宽的行为，比如可能只需要某个对象的一个部分，但是会把整个对象传回来

3. **新增错误状态码**

4. **Host头的处理**

   在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

5. **长连接**

   HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

### HTTP2.0

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能

#### HTTP复用？。。。

##### HTTP2.0之前没有复用，会带来什么结果？。。。

### cookie与session的区别

cookie主要用于存放用户的信息，以便用户下次登录的时候可以更快速地添加一下基本信息。

一般网页实现第二次直接登录的方法就是为用户信息生成一个token存放在用户的cookie中，下次就可以直接登录（为了安全每次重新登录都会更新token）

同时cookie还满足用户在访问一个网站的其他页面是也无需重新登录。

session主要用于保存用户状态，比如用户的购物车信息等。

session一般存放在服务器中，cookie一般存放在内存中（浏览器中）





## HTTPS

### 🌟HTTP和HTTPS区别

HTTP和HTTPS最大的区别就是安全性的区别，HTTP是使用明文传输，而HTTPS是使用密文传输的。

要生成密文就涉及到加密算法以及密钥的生成，所以HTTPS较HTTP的TCP协议基础上增加了SSL协议，所以建立连接的握手机制也比HTTP更复杂一些。

### HTTPS目的是解决HTTP哪些问题？

1. 窃听风险
2. 篡改风险
3. 冒充风险（中间人攻击）

### HTTPS如何解决上述问题

1. 采用混合加密的方式来实现信息的机密性，防止信息被窃听的风险
2. 摘要算法来实现校验数据的完整性，解决被篡改的风险
3. 身份验证机制防止冒充的风险

#### 混合加密

> 非对称加密：公钥加密私钥解密。客户端向服务器端申请服务器端的公钥，使用公钥对数据进行加密传输，服务器端收到密文后使用自己的私钥进行解密。

* 在通信建立之前采用非对称加密的方式
* 在通信建立之后采用对称加密来传输数据

#### 摘要算法

摘要算法通过给数据生成独一无二的指纹来校验数据的完整性，解决数据被篡改的风险。

发送方通过摘要算法算出要传输数据明文的指纹，并将指纹+明文一同加密成密文传输给接收方，接收方收到密文解密后通过相同的摘要算法计算明文的指纹，并与传输过来的指纹进行对比

#### 数字证书

**解决的问题**：非对称加密建立连接的过程中，客户端需要向服务器端申请它的公钥，用于后续加密消息传递密文，但这次申请没有安全保证，无法确认公钥的信任度。

借助第三方权威机构CA（数字证书认证机构），将服务器公钥放在数字证书中。

### 🌟HTTPS的建立连接过程

HTTPS的加密传输涉及到加密算法，加密算法有两种，对称加密和非对称加密。而HTTPS使用的是混合加密的方式，在简历连接时采用非对称加密，一旦连接建立，随后的通信使用对称加密进行传输。

HTTPS建立连接的过程主要有以下三个步骤：客户端验证服务器端的CA证书-双方协商生成对话密钥-双方使用密钥进行加密通信。

具体来说有四步：

1. clientHello，客户端向服务器端发送加密传输请求，传输的内容包括客户端的SSL协议版本，客户端支持的加密算法和一个随机数
2. serverHello：服务器端回应客户端，传输内容主要包括服务器端的CA证书，服务器端选择的加密算法，和第二个随机数
3. 客户端接下来通过操作系统或浏览器来验证服务器端的CA证书身份，如果验证成功则向服务器发送确认信息，包括第三个随机数，加密算法改变通知（要从非对称加密改为对称加密），和客户端握手结束通知（会将之前涉及的所有数据打包通过摘要算法生成一个最终结果）
4. 服务器端收到第三个随机数后通过三个随机数计算出本次通话的加密密钥，并向客户端传回：加密算法更改信息，和握手结束通知（数据摘要）

### 常见的网络攻击

1. SQL注入

2. 零日攻击

   **保护自身不受零日攻击影响最简便的方法，就是在新版本发布后及时更新。**

3. DDoS攻击

   DDoS攻击就是用大量请求压垮目标服务器，攻击者再利用DDoS攻击吸引安全系统火力，从暗中利用漏洞入侵系统。

   **避免DDoS攻击，首先，需通过内容分发网络（CDN）、负载均衡器和可扩展资源缓解高峰流量。其次，需部署Web应用防火墙（WAF），防止DDoS攻击隐蔽注入攻击或跨站脚本等其他网络攻击方法。**

4. 中间人攻击

5. 暴力破解密码

6. 网络钓鱼

### Diffie-Hellman密钥交换算法





## DNS

### DNS服务器

<img src="https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/202108181607953.png" alt="截屏2021-08-18 下午4.07.34" style="zoom:50%;" />

* 根DNS服务器：返回顶级DNS服务器地址
* 顶级DNS服务器：返回权威DNS服务器地址
* 权威DNS服务器：返回相应主机地址

### DNS的解析流程

1. 浏览器输入一个网址，发送DNS请求查找网址相应的IP地址。首先会发送给本地DNS服务器，本地DNS服务器一般是提供网络的运行商提供，并通过本地的DHCP配置在电脑上。

2. 如果本地的DNS服务器中没有想要找的域名对应的地址，那么本地DNS服务器接下来回去请求它对应的根DNS服务器。

3. 根域名服务器将请求分发到下一级的顶级DNS服务器

4. 顶级DNS服务器将请求再分发到再下一级权威DNS服务器

5. 权威DNS服务器会有结果IP地址，将这个IP地址返回给本地DNS服务器

6. 本地DNS服务器将结果返回给客户端

   <img src="https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/202108181714423.png" alt="截屏2021-08-18 下午5.14.25" style="zoom: 67%;" />

### 负载均衡

一个应用如果想要访问数据库，那么我们在应用中最好配置的是这个数据库的域名而不是数据库的IP地址，通过DNS进行IP地址的查询，这样数据库的IP发生变化的时候就不用去改应用中的IP地址。

更进一步，如果我们的应用被部署在多个服务器上，如果使用IP地址进行访问就是一对一的访问，这样如果访问量过大应用会承受不住，通过域名来访问应用，DNS可以每次给访问者不同的IP地址来进行应用的负载均衡。

## CDN

## NAT

### 网关

跨网关访问的时候牵扯到IP地址与MAC地址的变化

网关一般是一个路由器，是一个三层转发设备，三层转发设备是指在收到收据包的时候要取下MAC头和IP头两层头，判断其中的内容然后将数据转发出去。

### 静态路由

静态路由根据路由器自己维护的静态的路由表来进行数据包的转发。

### 路由过程中MAC头与IP头的变化

#### 欧洲十国游类型

<img src="https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/20210812155758.png" alt="截屏2021-08-04 下午2.40.31" style="zoom:50%;" />

整个流程下来**IP地址是不变的**，服务器A通过IP地址层层转发找到服务器B，期间每次转发都会通过ARP协议来获取下一跳的MAC地址，并更新源MAC地址和目标MAC地址。

#### 玄奘西行类型——公网与NAT

![截屏2021-08-04 下午2.40.58](https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/20210812155755.png)

服务器需要访问公网时，需要经过NAT网关将**内网IP地址转换为公网的IP地址**，服务器A想访问服务器B，需要知道服务器B在公网上的IP地址，到达服务器B的网关时再将目标IP地址转化为内网的地址。整个过程源IP地址并不需要改变成公网IP。

**注意以上都是以静态路由为示例**



## RPC协议

标准流程如下：

![截屏2021-08-30 下午5.43.19](https://raw.githubusercontent.com/Xiaogengenme/ImagesResource/main/202108301743416.png)

stub层：用于处理双方约定好的语法，语义，封装，解封装。

RPCRuntime主要用于处理高性能的传输以及网络的错误和异常。


### Process Management

### Threads and Concurrency

### Memory Management

### Interprocess Communication

### I/O Management

### POSIX Basics

管道：一个进程的输出转换为另一个进程的输入

### Basic Networking Concepts(wlan，vlan，lan，wan，防火墙)



# 内存管理

## 虚拟内存

### 1. 物理内存的弊端以及什么是虚拟内存

把程序都运行在物理内存上面，程序间的内存数据可能会相互影响不好管理。同时，程序运行在物理内存上也导致了内存使用率较低，程序运行内存地址不确定，容易出错等问题。

> 总结下来就是程序直接来操纵物理地址会造成数据安全性问题，内存使用率较低，执行过程中数据更改效率较低并且容易出错。

所以我们考虑在物理内存和程序之间加一个中间层，实现不同的进程能够被分配到一整块独占的虚拟内存空间，不同的程序访问不同的内存空间既保证了安全性也提升了效率。





# 线程与进程

### 1. 进程、线程、协程概念理解

1. 进程

   进程是系统进行资源分配和调度的基本单位，每个进程拥有自己独立的地址空间。

2. 线程

   线程是轻量级的进程，处理器调度的基本单位。线程自己基本上不拥有系统资源，只拥有一些在运行时必不可少的资源，可以与同属于同一个进程的其他线程来共享进程的资源。

   同一个进程中的多个线程可以并发执行，

3. 协程

   协程是一种用户态的轻量级线程，协程的调度完全又用户控制。

   从内存空间而言，协程拥有自己的寄存器上下文和栈，当协程进程调度切换时，将寄存器上下文和栈的数据保存到其他地方，在切回来的时候再恢复回来，使得协程的上下文切换速度很快。

#### 进程与线程之间的比较



#### 线程和协程之间的比较：

1. 线程和进程都可以同时拥有多个协程
2. 进程与线程都是使用同步机制，而协程使用的是异步机制
3.  

### 2. 进程间的通信方式

因为进程之间有自己独立的内存空间，所以进程之间传递数据必须通过内核，一个进程将数据从用户空间中拷贝出来存入内存缓冲区，另一个进程将数据从内存缓冲区中读走，这就是进程间通信的基本概念：

七种方式：

#### 第一类：传统的Unix通信机制

##### 1. 管道/匿名管道（pipe）

* 管道通信是半双工的，只能由一方传递数据给另外一方；需要双方通信时，需要建立起两个管道连接；
* 管道只能用于父子进程，或者兄弟进程这种有亲缘关系的进程；
* 管道是一个文件，一个进程向文件中写入数据，另一个进程读出；
* 读入和写出的顺序具有管道的特点，从缓冲区的末尾添加数据，并从缓冲区的头部读出。

局限性：

* 只支持单向的数据流
* 只能用于有亲缘关系的进程之间
* 没有名字
* 缓冲区大小有限
* 传递无格式字节流，那么需要管道通信双方事先约定好多少个字节算一个消息和一些其他约定

##### 2. 有名管道

由于匿名管道没有名字，只能用于有亲缘关系的进程之间通信，有名管道克服了这一点，因为有名，其提供了一个路径名与进程进行关联，所以支持没有亲缘关系的进程进行通信。

有名管道的名字存放在文件系统中，内容存放在内存中。

##### 3. 信号（Signal）

* 信号可以在任何时候发给某个进程，而无需知道该进程的状态
* 如果该进程当前未处于执行状态，信号由内核保存起来，该进程恢复执行后再传递给它
* 信号可以被阻塞，如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。<u>（我猜应该是被接收的进程设置为阻塞吧？）</u>

信号来源：信号是对操作系统中断机制的一种模拟，是一种异步的通信方式，信号可以在用户态的进程和内核之间进行交互，内核可以利用信号来通知用户态的进程发生了哪些系统事件。来源主要有两个：

1. 硬件来源：用户按ctrl+c按键等
2. 软件来源：其他进程调用kill pid时

信号的处理流程：

> 信号的处理为什么被称为是异步的？

1. 信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；
2. 操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
3. 目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。

###### 抢占式与非抢占式内核

> 抢占式内核指的是高优先级的进程在进入了就绪态之后，内核会直接抢占低优先级的进程的执行资源，优先执行高优先级的进程。非抢占式资源中，除非进程主动放弃CPU，否则进程会一直执行下去。
>
> 非抢占式内核的优点：
>
> 1. 中断响应快，因为一旦一个进程A（就算是高优先级）请求CPU时间片时，内核会迅速拒绝它的这个请求，并将其从就绪态转换为挂起状态，等到当前正在执行的进程B（就算是低优先级，被中断的那个进程）主动放弃CPU时间片才会执行进程A。
> 2. 允许使用不可重入函数。
> 3. 几乎不需要信号量来保护共享数据。但不是绝对的，<u>反例是什么？？？</u>
>
> 非抢占式内核的缺点：不知道正在执行的进程什么时候会释放CPU资源，想要执行的进程不知道什么时候才会执行。
>
> 抢占式内核的优点：
>
> 1. 进程的响应时间是可靠的，高优先级的进程可以随时剥夺低优先级进程的执行权。
>
> 抢占式内核的缺点：不能随意使用不可重入函数，（**不可重入函数：可以理解为涉及到共享数据资源的函数**）。如果抢占式内核使用不可重入函数，发生了CPU执行资源的抢占，正在读写共享数据资源的进程资源被剥夺的话，有可能会产生数据问题。可以使用互斥量与信号量进行互斥、同步操作。
>
> 所以说volatile关键字保证的是线程的同步？而不是线程的安全？

###### 可重入与线程安全

> volatile的作用是保证共享变量的可见性和禁止指令重排序。
>
> 线程安全是一个比较大的概念，volatile可以说是实现线程安全的一个方法。如果一个方法的实现，一段程序的执行中，不会出现数据emmmmm看百科↓
>
> 百度百科：“在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。”
>
> * 可重入与线程安全:
>
>   "如果一个函数能够安全地同时被多个线程调用而得到正确的结果，那么，我们说这个函数是线程安全的。"				——百度百科
>
>   ~~**一个不可重入的函数一定是线程安全的，但是一个线程安全的函数不一定是不可重入的。**~~
>
>   **一个可重入函数一定是线程安全的，但是一个线程安全的函数不一定是可重入的。因为不可重入的函数可以通过一些信号量等同步机制使其成为一个线程安全的函数。**
>
>   （注意注意注意！！可重入是指这个函数已经很安全了，不会涉及到线程不安全的问题，所以可以随便重入）
>
>   可重入函数可以由多于一个任务并发使用，随时中断，之后再切换回来不会有数据问题。相反地，不可重入( Non - Reentrant)函数不能由超过一个任务所共享，除非能确保函数的互斥（或者使用信号量，或者在代码的关键部分禁用中断）。

##### 4. 消息队列

* 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示
* 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
* 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。
* 消息队列允许一个或多个进程向它写入与读取消息.
* 先进先出，但是消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。
* 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。

##### 5. 共享内存

* 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
* 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
* 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

##### 6. 信号量（semaphore）

信号量作为一个计数器，用于多进程对共享数据的访问，信号量的意图在于**进程间的同步**。

为了获取共享资源，进程可以进行如下操作：

1. 创建一个信号量：由调用者指定初始值，对于二值信号量，通常是1也可以是0
2. 等待一个信号量（消费一个信号量）：该操作会测试这个信号量的值，如果小于0就阻塞。成为P操作
3. 挂出一个信号量：将信号量值+1，成为V操作

信号量与互斥量之间的区别：

1. 互斥量用于线程的互斥，信号量用于线程的同步。

   这里就牵涉到互斥与同步的区别：

   互斥，是指同一个数据资源在一段时间只允许一个线程的访问，具有互斥性和排他性，但是虽然完成互斥但并不能控制访问资源的线程的顺序。

   同步：同步则可以利用一些机制完成线程对资源的有序访问。

   > 实现线程同步的机制有哪些呢？

2. 互斥量只能是0或1，但是信号量可以是一个正整数。

   信号量实现的功能更丰富，可以控制对于共享同一资源的多个线程的控制。如果是单值信号量那么就和互斥量无异。

3. <u>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。？？？这句话对吗？</u>



##### 7. 套接字

套接字是我们平时用到的最常见的进程通信方式，可以实现在不同主机上进程的通信。具体可以看网络编程那一章。



### 3. 进程的同步

#### 1. 临界区

通过在多线程情况下串行化地访问共享资源实现数据安全。

不足：只能对用一个进程中的线程进行串行化地处理，不能跨进程。也不能进程和进程串行化。

#### 2. 互斥量

#### 3. 信号量

#### 事件



### 4. 线程的同步(Java)

“线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态”（百度百科）

线程的同步是一个程序目标，殊途同归我们可以使用很多方法来实现线程的同步。Java中有：

#### Synchronized

#### volatile

#### wait和notify

#### ReentrantLock（AQS，包括其他Semaphore、catchdown Latch等）

#### ThreadLocal

#### 阻塞队列

#### 原子类

